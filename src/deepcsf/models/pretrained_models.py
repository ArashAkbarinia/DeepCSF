"""

"""

import os
import sys

import torch
import torch.nn as nn

from torchvision.models import segmentation

from . import model_utils
from . import vqvae
from .taskonomy import taskonomy_network


class LayerActivation(nn.Module):
    def __init__(self, model, layer_name, conv_bn_relu='relu'):
        super(LayerActivation, self).__init__()

        # FIXME: only for resnet at this point
        self.relu = None
        self.sub_layer = None
        self.sub_conv = None

        whole_layers = ['layer%d' % e for e in range(1, 6)]
        if layer_name in whole_layers:
            print('Activation for the whole %s' % layer_name)
            last_areas = [4, 5, 6, 7, 8]
            # FIXME at somepoint go to 0 indexing to avoid all this mess
            lind = last_areas[int(layer_name[-1]) - 1]
            self.features = nn.Sequential(*list(model.children())[:lind])
        elif layer_name == 'fc':
            self.features = model
        elif layer_name == 'avgpool':
            self.features = nn.Sequential(*list(model.children()))
        else:
            if conv_bn_relu == 'relu':
                self.relu = nn.ReLU(inplace=True)
                which_fun = model_utils.resnet_bn_layer
            elif conv_bn_relu == 'bn':
                which_fun = model_utils.resnet_bn_layer
            else:
                which_fun = model_utils.resnet_conv_layer

            name_split = layer_name.split('.')
            sub_layer = None
            sub_conv = None
            # -3 because the features were autogenerated and start from 4
            area_num = int(name_split[0]) - 3
            layer_num = int(name_split[1])
            conv_num = int(name_split[2][-1])
            last_areas = [1, 4, 5, 6, 7]
            last_area = last_areas[area_num]
            if area_num > 0:
                layerx = list(model.children())[last_areas[area_num]]
                sub_layer, sub_conv = which_fun(layerx, layer_num, conv_num)
            self.features = nn.Sequential(*list(model.children())[:last_area])
            self.sub_layer = sub_layer
            self.sub_conv = sub_conv

    def forward(self, x):
        x = self.features(x)
        if self.sub_layer is not None:
            x = self.sub_layer(x)
        if self.sub_conv is not None:
            x = self.sub_conv(x)
        if self.relu is not None:
            x = self.relu(x)
        return x


def resnet_features(model, network_name, layer, target_size):
    if 224 % target_size == 0:
        scale_factor = target_size / 224
        features, org_classes = _resnet_features_224(model, network_name, layer)
    elif 256 % target_size == 0:
        scale_factor = target_size / 256
        features, org_classes = _resnet_features_256(model, network_name, layer)
    return features, org_classes, scale_factor


def _resnet_features_224(model, network_name, layer):
    if type(layer) is str:
        if layer == 'area0':
            layer = 4
            if network_name in ['resnet18', 'resnet34']:
                org_classes = 200704
            elif 'taskonomy_' in network_name:
                org_classes = 186624
            else:
                org_classes = 200704
        elif layer == 'area1':
            layer = 5
            if network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 200704
            elif 'taskonomy_' in network_name:
                org_classes = 186624
            else:
                org_classes = 802816
        elif layer == 'area2':
            layer = 6
            if 'taskonomy_' in network_name or network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 100352
            else:
                org_classes = 401408
        elif layer == 'area3':
            layer = 7
            if network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 50176
            elif 'custom' not in network_name and (
                    'deeplabv3_' in network_name or 'fcn_' in network_name
            ):
                org_classes = 802816
            else:
                org_classes = 200704
        elif layer == 'area4':
            layer = 8
            if network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 25088
            elif 'custom' not in network_name and (
                    'deeplabv3_' in network_name or 'fcn_' in network_name
            ):
                org_classes = 1605632
            elif 'taskonomy_' in network_name:
                org_classes = 401408
            else:
                org_classes = 100352
        elif layer == 'fc':
            # FIXME
            org_classes = 1000
            return model, org_classes
        elif layer == 'encoder':
            if 'taskonomy_' in network_name:
                layer = len(list(model.children()))
                org_classes = 8 * 14 * 14
        else:
            sys.exit('Unsupported layer %s' % layer)
    features = nn.Sequential(*list(model.children())[:layer])
    return features, org_classes


def _resnet_features_256(model, network_name, layer):
    if type(layer) is str:
        if layer == 'area0':
            layer = 4
            if network_name in ['resnet18', 'resnet34']:
                org_classes = 262144
            elif 'taskonomy_' in network_name:
                org_classes = 246016
            else:
                org_classes = 262144
        elif layer == 'area1':
            layer = 5
            if network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 262144
            elif 'taskonomy_' in network_name:
                org_classes = 246016
            else:
                org_classes = 1048576
        elif layer == 'area2':
            layer = 6
            if 'taskonomy_' in network_name or network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 131072
            else:
                org_classes = 524288
        elif layer == 'area3':
            layer = 7
            if network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 65536
            elif 'custom' not in network_name and (
                    'deeplabv3_' in network_name or 'fcn_' in network_name
            ):
                org_classes = 1048576
            else:
                org_classes = 262144
        elif layer == 'area4':
            layer = 8
            if network_name in [
                'resnet18', 'resnet34', 'resnet_basic_custom',
                'resnet18_custom', 'deeplabv3_resnet18_custom'
            ]:
                org_classes = 32768
            elif 'custom' not in network_name and (
                    'deeplabv3_' in network_name or 'fcn_' in network_name
            ):
                org_classes = 2097152
            elif 'taskonomy_' in network_name:
                org_classes = 524288
            else:
                org_classes = 131072
        elif layer == 'encoder':
            if 'taskonomy_' in network_name:
                layer = len(list(model.children()))
                org_classes = 8 * 16 * 16
        else:
            sys.exit('Unsupported layer %s' % layer)
    features = nn.Sequential(*list(model.children())[:layer])
    return features, org_classes


def get_pretrained_model(network_name, transfer_weights):
    if 'taskonomy_' in network_name:
        # NOTE: always assumed pretrained
        feature_task = network_name.replace('taskonomy_', '')
        model = taskonomy_network.TaskonomyEncoder()
        feature_type_url = taskonomy_network.TASKONOMY_PRETRAINED_URLS[feature_task + '_encoder']
        checkpoint = torch.utils.model_zoo.load_url(feature_type_url, model_dir=None, progress=True)
        model.load_state_dict(checkpoint['state_dict'])
    elif os.path.isfile(transfer_weights[0]):
        # FIXME: cheap hack!
        if 'vqvae' in network_name or 'vqvae' in transfer_weights[0]:
            vqvae_info = torch.load(transfer_weights[0], map_location='cpu')

            backbone = {
                'arch_name': vqvae_info['backbone']['arach'],
                'layer_name': vqvae_info['backbone']['area'],
            }
            # hardcoded to test one type
            hidden = vqvae_info['backbone']['hidden']
            k = vqvae_info['backbone']['k']
            kl = vqvae_info['backbone']['kl']
            model = vqvae.Backbone_VQ_VAE(
                hidden, k=k, kl=kl, num_channels=3, colour_space='rgb2rgb',
                task=None, out_chns=3, cos_distance=False, use_decor_loss=False, backbone=backbone
            )
            model.load_state_dict(vqvae_info['state_dict'])
            print('Loaded the VQVAE model!')
        else:
            model = model_utils.which_network(
                transfer_weights[0], transfer_weights[2],
                num_classes=1000 if 'class' in transfer_weights[2] else 21
            )
    elif '_scratch' in network_name:
        model = model_utils.which_architecture(network_name.replace('_scratch', ''))
    elif 'deeplabv3_' in network_name or 'fcn_' in network_name or 'deeplab' in network_name:
        model = segmentation.__dict__[network_name](pretrained=True)
    else:
        model = model_utils.which_network(transfer_weights[0], 'classification', num_classes=1000)
    return model


def get_backbone(network_name, model):
    if 'vqvae' in network_name:
        return model.backbone_encoder.features
    elif 'deeplabv3_' in network_name or 'fcn_' in network_name or 'deeplab' in network_name:
        return model.backbone
    return model
